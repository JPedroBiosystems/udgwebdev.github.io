---
layout: post
title: Design Patterns para Javascript - Parte 2
tags: Javascript
keywords: Design Patterns, Javascript, Pattern Factory, Pattern Mixin, Pattern Module
description: ! 'Continuando a série de posts relacionado a Design Patterns para Javascript, hoje apresentarei os patterns: Module, Factory e Mixin.'
published: true
---
<figure class="post-image">
  <img src="{{ site.url }}/images/javascript-logo.jpg" width="250" height="250" alt="Javascript Desing Pattenrs" title="Javascript Desing Pattenrs">
  <figcaption>Javascript Desing Pattenrs</figcaption>
</figure>
<div class="post-content">
  <p>Continuando a série de posts relacionado a <strong>Design Patterns para Javascript</strong> hoje apresentarei os patterns: <strong>Module, Factory e Mixin</strong>. Caso ainda não tenha visto a primeira parte desse post, veja-o neste link: <a href="{{ site.url }}/design-patterns-para-javascript-parte-1/" title="Design Patterns para Javascript – Parte 1" target="_blank">Design Patterns para Javascript - Parte 1.</a></p>
  <h2>Pattern Module</h2>
  <p>Este padrão popular foi criado para definir um meio de encapsulamento privado e público de classes pela engenharia de software convecional.</p>
  <p>Em Javascript, este pattern é usado para emular o conceito de classes provendo um meio de incluir atributos e funções públicas e privadas dentro de um objeto, protegendo as particulares partes de um escopo global. O resultado disso é a redução de conflitos de objetos e funções que possuem o mesmo nome quando diversos scripts são inclusos na mesma página.</p>
  <p>Este conceito de métodos públicos e privados permite que variáveis sejam acessados apenas pelo próprio módulo, protegendo os componentes privados de um acesso externo apartir de outras entidades, que só poderão ver as informações públicas do mesmo. Veja abaixo um exemplo de como implementá-lo:</p>

{% highlight javascript %}
// Criando um módulo
var contadorModule = (function(){
  // Atributo privado de acesso externo.
  var contador = 0;
  return {
  // Funções públicas para acesso externo.
    incrementarContador: function() {
      return contador++;
    },
    resetContador: function() {
      console.log('O contador parou no valor:' + contador);
      contador = 0;
    }
  };
})();
// Somente estas funções poderão ser utilizadas.
contadorModule.incrementarContador();
contadorModule.resetContador();
{% endhighlight %}

  {% include content-ads.ext %}

  <h2>Pattern Factory</h2>
  <p>Parecido com o <a href="{{ site.url }}/design-patterns-para-javascript-parte-1/" title="Design Patterns para Javascript – Parte 1" target="_blank">Pattern Creational</a>, o <strong>Pattern Factory</strong> resolve alguns problemas de criação de objetos sem especificar o nome exato do objeto a ser instanciado.</p>
  <p>Esse é o conceito de uma fábrica de objetos, pelo qual é definido uma interface para criação desses objetos por onde é permitido que subclasses decidam qual o objeto a ser instanciado. Esse pattern lida com o problema através da definição separada de funções para criação dos objetos, pelo qual sub-classes são capazes de sobrescrever e decidir qual tipo de fábricação de objeto a ser criada. Com frequência esse pattern é encontrado em frameworks onde o código-fonte precisa ser criado em tipos de objetos particulares que são utilizados através de subclasses.</p>
  <h6>Quando utilizá-lo?</h6>
  <ul>
    <li>Quando há utilização de instâncias de objetos em um nível alto de complexidade.</li>
    <li>Quando há necessidade de gerar diferentes instâncias de objetos independente do ambiente.</li>
    <li>Quando você necessita trabalhar com objetos que compartilham as mesmas propriedades.</li>
  </ul>
  <h6>Quando não utilizá-lo?</h6>
  <ul>
    <li>Geralmente é uma boa prática não usar esse pattern em todas as situações, isso ocorre devido a grande complexidade de sua implementação, sendo substituído facilmente pelo <a href="{{ site.url }}/design-patterns-para-javascript-parte-1/" title="Design Patterns para Javascript – Parte 1" target="_blank">Pattern Constructor</a>.</li>
    <li>Sua implementação exige um trabalho extra de implementação e seus testes.</li>
  </ul>
  <p>A seguir veja um exemplo de seu código:</p>

{% highlight javascript %}
var CarroFactory = (function() {
  var Carro = function (modelo, ano, cor){
    this.modelo = modelo;
    this.ano    = ano;
    this.cor    = cor;
  };
  return function (modelo, ano, cor) {
    return new Carro(modelo, ano, cor);
  };
})();
// Instanciando um objeto Carro via CarroFactory.
var civic = new CarroFactory("Honda Civic", 2009, 20000);
var mondeo = new CarroFactory("Ford Fusion", 2010, 5000);
{% endhighlight %}

  <h2>Pattern Mixin</h2>
  <p>Mixin são classes que fornecem functionalidades a serem herdadas pelas subclasses. Isso significa que com o Mixin é possível colecionar funções e objetos herdados por múltiplos Mixin entre diversas heranças.</p>

{% highlight javascript %}
// Construtor de um objeto Carro.
var Carro = function(arg){
  this.modelo = arg.modelo || 'Não informado';
	this.cor    = arg.cor || 'Não informado';
};
// Estrutura de um objeto Mixin
var Mixin = function(){};
Mixin.prototype = {
	acelerar: function(){
		console.log('acelerando o carro.');
	},
	parar: function(){
		console.log('parando o carro.');
	}
};
// Função que injeta as funções Mixin para o objeto Carro
function mixinInjector(classeReceptora, classeProvedora) {
  // Um Mixin fornecendo alguns métodos
  if (arguments[2]) {
    for (var i=2, len=arguments.length; i < len; i++) {
      classeReceptora.prototype[arguments[i]] = classeProvedora.prototype[arguments[i]];
    }
  }
  // Um Mixin fornecendo todos os métodos
  else {
    for (var metodos in classeProvedora.prototype) {
      // verificando se a classe receptora já possui tal método do loop...
      if (!classeReceptora.prototype[metodos]) {
        classeReceptora.prototype[metodos] = classeProvedora.prototype[metodos];
      }
    }
  }
}
// Executando um Mixin...
mixinInjector(Carro, Mixin,'acelerar','parar');
// Instanciando um Carro
var ford = new Carro({modelo:'Ford Escort', cor:'azul'});
// Utilizando as funções herdadas pelo Mixin...
ford.acelerar();
ford.parar();
{% endhighlight %}

  <p>Neste exemplo criamos um objeto <strong>Carro</strong> sem definir as funções <strong>acelerar()</strong> e <strong>parar()</strong>. Porém criamos um objeto <strong>Mixin</strong> que injetou essas funcionalidades para o objeto Carro.</p>
  <p>Não deixe de ler as referências abaixo para aprender mais e mais sobre os <strong>Desing Patterns para Javascript</strong>, é um excelente material!</p>

  <p>Fonte: <a href="http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/" title="Essetial Design Patterns - Addy Osmani" target="_blank">Essential Design Patterns - Addy Osmani</a></p>
</div>
