---
layout: post
title: Node.js para leigos - Trabalhando com HTTP
tags: Node.js
keywords: Curso de Node.js, Node.js, Node.js para leigos, Trabalhando com HTTP
published: true
description: Node.js é uma plataforma multiprotocolo, ou seja, com ele será possível trabalhar com HTTP, DNS, TCP, WebSockets e muito mais.
---
<figure class="post-image">
  <img src="{{ site.url }}/images/nodejs-para-leigos.jpg" width="250" height="137" alt="Curso de Node.js" title="Curso de Node.js">
  <figcaption>Curso de Node.js</figcaption>
</figure>
<div class="post-content">
    <p>Node.js é uma plataforma multiprotocolo, ou seja, com ele será possível trabalhar com HTTP, DNS, TCP, WebSockets e muito mais. Porém um dos protocolos mais usados para desenvolver sistemas web é o protocolo HTTP, de fato é o protocolo com a maior quantidade de módulos disponíveis para trabalhar no Node.js.</p>
    <p>Hoje apresentarei um pouco sobre como desenvolver uma aplicação HTTP, na prática desenvolveremos um simples sistema web utilizando o módulo nativo HTTP e também apresentando alguns módulos mais estruturados para desenvolver aplicações complexas.</p>
    <p>Toda aplicação web necessita de um servidor web em execução para disponibilizar todos os seus recursos, na prática você irá desenvolver uma <strong>aplicação servidora</strong>, ou seja, além de programar todas funcionalidades da sua aplicação você também terá que configurar na própria aplicação aspectos sobre como <strong>ela servirar seus recursos para o cliente</strong> quando for executá-la. Essas <strong>configurações são conhecidas como middleware</strong>, é claro que é um trabalho dobrado no começo, mas isso traz a liberdade de configurar cada mínimo detalhe do sistema, ou seja, permite desenvolver algo mais performático e controlado pelo programador. Caso performance não seja prioridade no desenvolvimento do seu sistema, recomendo que utilize alguns módulos famosos que já vem com o mínimo necessário de configurações prontas para não perder tempo trabalhando sobre esse aspecto, alguns módulos conhecidos são: <a href="http://www.senchalabs.org/connect/" title="Connect" target="_blank">Connect</a>, <a href="http://expressjs.com/" title="ExpressJS" target="_blank">Express</a>, <a href="http://geddyjs.org/" title="Geddy" target="_blank">Geddy</a> <a href="https://github.com/joyent/node/wiki/Modules#wiki-web-frameworks" title="Node.js Web Frameworks" target="_blank">e muito mais aqui</a>. Esses módulos já são preparados para trabalhar desde uma <strong>infraestrutura mínima e básica (Microframeworks)</strong> até uma <strong>infraestrutura mais enxuta com padrões do tipo MVC (Model-View-Controller) e outros padrões de projetos (MVC Frameworks).</strong></p>
    <p>De ínicio usaremos apenas o <strong><a href="http://nodejs.org/api/http.html" title="Documentação da API HTTP" target="_blank">módulo nativo HTTP</a></strong>, pois precisamos entender todo conceito do mesmo, visto que todos os frameworks citados acima utilizam ele como estrutura inicial em seus projetos.</p>
{% highlight javascript %}
var http = require('http');

var server = http.createServer(function(request, response){
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("<html><body><h1>Olá Node.js!</h1></body></html>");
  response.end();
});

server.listen(3000, function(){
  console.log('Executando Servidor HTTP');
});
{% endhighlight %}
    <p>Esse é um exemplo clássico e simples de um servidor web sendo executado na <strong>porta 3000</strong>, respondendo por padrão na <strong>rota raíz "/"</strong> um resultado em <strong>formato html</strong> com a mensagem <strong>Olá Node.js!</strong>.</p>

    {% include content-ads.ext %}

    <p>Agora complicando mais, vamos adicionar duas rotas nesse sistema, uma rota para página de erro e também um link em cada página html para intergir uma com a outra:</p>
{% highlight javascript %}
var http = require('http');

var server = http.createServer(function(request, response){

  response.writeHead(200, {"Content-Type": "text/html"});

  if(request.url == "/"){
    response.write("<html><body><h1>Olá Node.js!</h1>");
    response.write("<a href='/bemvindo'>Bem vindo</a>");
    response.write("</body></html>");
  }else if(request.url == "/bemvindo"){
    response.write("<html><body><h1>Bem-vindo ao Node.js!</h1>");
    response.write("<a href='/'>Olá Node.js</a>");
    response.write("</body></html>");
  }else{
    response.write("<html><body><h1>Página não encontrada!</h1>");
    response.write("<a href='/'>Voltar para o início</a>");
    response.write("</body></html>");
  }
  response.end();
});

server.listen(3000, function(){
  console.log('Executando Servidor HTTP');
});
{% endhighlight %}

    <p>Todo leitura de url é obtida através do método <strong>request.url</strong> que retorna uma string sobre o que foi digitado no endereço url do seu browser. Endereços urls do protocolo http possui alguns padrões como <strong>query strings (?nome=joao)</strong> e <strong>pathnames (/admin)</strong> e sinceramente tratar toda string url seria trabalhoso demais, sendo que já existem diversos exemplos prontos para isso. No Node.js existe o <strong><a href="http://nodejs.org/api/url.html" title="Documentação da API URL" target="_blank">módulo chamado url</a></strong> responsável por realizar um <strong>parser e formatação de strings url</strong>, veja como um exemplo abaixo:</p>

{% highlight javascript %}
var http = require('http');
var url = require('url');

var server = http.createServer(function(request, response){

  // Faz um parse da string url digitada.
  var result = url.parse(request.url, true);

  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("<html><body>");
  response.write("<h1>Dados da query string</h1>");
  // Itera o resultado de parâmetros passados via query string.
  for(var key in result.query){
    response.write("<h2>"+key+" : "+result.query[key]+"</h2>");
  }
  response.write("</body></html>");
  response.end();
});

server.listen(3000, function(){
  console.log('Executando Servidor HTTP');
});
{% endhighlight %}

    <p>Digite no seu browser a url: <strong>http://localhost:3000/?nome=joao&idade=22&email=joao@mail.net</strong> para ver os resultados tratados pelo <strong>parse de url</strong>. Agora vamos separar o código HTML do código Node.js em arquivos distintos, para isso utilizaremos o <strong><a href="http://nodejs.org/api/fs.html" title="Documentação da API FS" target="_blank">módulo nativo FS (File System)</a></strong> que faz tratamento de arquivos, que no nosso caso será leitura de arquivo HTML.</p>

{% highlight javascript %}
// app.js
var http = require('http');
var fs = require('fs');

var server = http.createServer(function(request, response){
  fs.readFile(__dirname + '/index.html', function(err, html){
    response.writeHeader(200, {'Content-Type': 'text/html'});
    response.write(html);
    response.end();
  });
});

server.listen(3000, function(){
  console.log('Executando Servidor HTTP');
});
{% endhighlight %}

{% highlight html %}
<!-- index.html -->
<!DOCTYPE html>
<html>
  <head>
    <title>Hello World</title>
  </head>
  <body>
    <h1>Hello World</h1>
  </body>
</html>
{% endhighlight %}

    <p>Neste código temos dois detalhes interessantes a citar, primeiro é a constante global chamada <strong>__dirname</strong> que retona uma string referente ao endereço raíz da aplicação, é uma variável muito útil, pois através dela podemos referenciar pastas e arquivos internos. </p>
    <p>Outro detalhe é o método <strong>fs.readFile()</strong>, repare que o resultado da leitura do <strong>arquivo index.html</strong> é enviado via <strong>função de callback</strong>, ou seja através da <strong>function(erro, html) que é um parâmetro da função fs.readFile()</strong>, na prática diversos módulos trabalham dessa forma no Node.js, pois o retorno de resultados através de funções callbacks são tratados de forma assíncrona <strong>(característica principal do Javascript)</strong> e isso é algo muito interessante pois permite tratar a execução das rotinas da aplicação de forma paralela, e isso você usará frequentemente no Node.js. Alguns módulos apresentam em suas documentações duas alternativas de trabalhar com uma mesma função, são elas conhecidas como <strong>execução síncrona e assíncrona.</strong> Sempre que puder <strong>utilize as versões assíncronas</strong> em seus projetos, pois as <strong>execuções assíncronas são mais perfomáticas</strong> e normalmente <strong>não bloqueiam</strong> a execução de outras <strong>rotinas síncronas</strong> do seu sistema, mesmo quando ocorrem problemas durante suas execuções.</p>
    <p>Por hoje é só galera, passei o básico e essencial guia de sobrevivência Node.js com protocolo HTTP, espero que tenham gostado, se surgir dúvidas, problemas ou sugestões, comentem abaixo ou entrem em contato comigo, ok? Até a próxima!</p>
</div>
