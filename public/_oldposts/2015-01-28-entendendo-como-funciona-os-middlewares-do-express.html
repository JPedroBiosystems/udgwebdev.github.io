---
layout: post
title: Entendendo como funciona os middlewares do Express
tags: Node.js
keywords: Middlewares, Express, Node.js
published: true
description: O assunto desse post será sobre o que é e como implementar middlewares em um aplicação web que utiliza o framework Express.
image_url: express4.jpg
---
<figure class="post-image">
  <img src="{{ site.url }}/images/express4.jpg" width="250" height="76" alt="Middlewares do Express" title="Middlewares do Express">
  <figcaption>Middlewares do Express</figcaption>
</figure>
<div class="post-content">
  <p>Neste post vou explicar uma dica simples e extremamente útil para os devs que trampam com aplicações web para Node.js. O assunto será sobre o que é e como implementar middlewares em um aplicação web que utiliza o framework Express.</p>
  <h2>O que são middlewares?</h2>
  <p>Quando você cria uma rota em sua aplicação web, por exemplo:</p>

{% highlight javascript %}
app.get("/home", function(request, response) {
  response.end("HOME");
});
{% endhighlight %}

  <p>Você libera uma área de sua aplicação para que usuários acessem via browser ou outras aplicações acessem através de algum framework http client.<br>
    Quando essa rota é acessada, dois objetos principais surgem no callback dessa função, eles são:</p>

  <ol>
    <li><strong>request</strong>: ele é responsável por carregar dados da requisição que esta sendo realizada, geralmente vem com dados do cliente e algums parâmetros de input, como querystrings, parâmetros de rotas e body de um formulário. Em resumo, este objeto contém diversos dados do cliente.</li>
    <li><strong>response</strong>: este objeto permite que o servidor envie uma resposta para o cliente que realizou uma requisição. Aqui você pode enviar um html, json, dados via header, redirecionar a resposta para uma outra requisição, em geral este é um objeto focado em dar uma resposta para o cliente.</li>
  </ol>

  <p>
  Este conceito de requisição e resposta não é do Express, e sim do <a href="http://pt.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank">protocolo HTTP</a>, ou seja, outras plataformas e linguagens de programação que trabalham com este protocolo seguem essa mesmo mecanismo.
  <br>
  Geralmente quando criamos uma aplicação web, queremos não só criar rotas na aplicação como também queremos tratar de uma forma padrão todas as requisições e respostas das rotas, sem precisar tratar repetitivamente todos os códigos das rotas. Por exemplo, se quero configurar que todas as rotas retornem uma resposta em formato gzip, praticamente não é necessário rodar uma função de gzip no final de todas as rotas, você pode injetar uma função que intercepte todas as requisições de forma que converta uma resposta em gzip. Esse conceito de interceptar requisições é o que chamamos de middleware. Os middlewares são funções que podem tratar os inputs e outputs das rotas antes e ou depois que uma rota é processada, ou seja, você pode criar um middleware que intercepta e verificar se uma requisição esta enviando um header específico e que caso o mesmo não esteja enviando o header ela retorne uma tela de erro para o usuário, negando a requisição de acessar uma determinada rota da aplicação, neste caso você criou e inejtou um middleware que trata uma pré-requisição. Você também pode criar um middleware que no final de cada resposta de uma rota, retorne também um header com metadados da resposta, por exemplo, headers de paginação de dados. Neste caso estamos criando um middleware de pós-requisição. Não há limites ao injetar middlewares, você pode criar e configurar N middlewares em sua aplicação, porém é sempre bom entender o que são cada middlewares e principalmente a ordem que cada middleware é injetado afeta no processamento de uma rota, ou seja, caso você injete middlewares em uma ordem errada, como efeito colateral sua aplicação pode responder ou até mesmo não processar corretamente suas rotas, por isso é extremamente importante entender o que cada middleware faz e em que ordem injetá-los.
  </p>

  <h2>Identificando os middlewares</h2>
  <p>Se você já criou alguma vez um app usando Express, consequentemente você precisou configurar alguns middlewares e talvez nem tinha percebido que eram middlewares. Veja o exemplo abaixo:</p>

{% highlight javascript %}
var express = require("express");
var morgan = require("morgan");
var compression = require("compression");
var app = express();

// injetando alguns middlewares...
app.use(morgan());
app.use(compression());

// criando a rota principal
app.get("/", function(req, res) {
  res.json({status: "Hello!"});
});

app.listen(3000, function() {
  console.log("Servidor rodando!");
});
{% endhighlight %}

  {% include content-ads.ext %}

  <p>
  Neste exemplo criei um simples app Express, usando 2 middlewares, um middleware é o módulo <a href="https://www.npmjs.com/package/compression" target="_blank">compression</a> que compacta as respostas para formato gzip e o outro middleware é o módulo <a href="https://www.npmjs.com/package/morgan" target="_blank">morgan</a> responsável por gerar logs de requisição.
  <br>
  Por último, criei uma rota que apenas retornar o json <code>{status: "Hello!"}</code> quando é acessado seu endereço <a href="http://localhost:3000/" target="_blank">http://localhost:3000/</a>.
  <br>
  <strong>Obs.:</strong> Caso queira rodar esse server, salve esse código com o nome <code>app.js</code>, em seguida rode os comandos:</p>

{% highlight bash %}
npm install express compression morgan
node app.js
{% endhighlight %}

  <p>Por último acesse no browser o endereço: <a href="http://localhost:3000/" target="_blank">http://localhost:3000/</a>.</p>

  <p>
  Como já tinha dito antes, é muito importante entender o que cada middleware faz e principalmente se eles estão sendo injetados em uma ordem correta, senão um middleware vai sobreescrever a ação do outro ou sua aplicação vai responder de forma inesperada.
  <br>
  Quer ver na prática? Faça a seguinte alteração, mude o seu app.js para o seguinte código:
  </p>

{% highlight javascript %}
var express = require("express");
var morgan = require("morgan");
var compression = require("compression");
var app = express();

app.get("/", function(req, res) {
  res.json({status: "Hello!"});
});

app.use(morgan());
app.use(compression());

app.listen(3000, function() {
  console.log("Servidor rodando!");
});
{% endhighlight %}

  <p>Neste caso mudei a ordem dos middlewares morgan e compression, injetando-o depois da rota "/", ou seja, neste caso esses middlewares não irão gerar logs e respectivamente compactar a resposta para gzip, pois a rota vai responder antes da execução desses middlewares. Afinal uma rota também é considerada como um middleware.</p>

  <h2>Implementando um middleware</h2>

  <p>Ao criar um app Express, de início você usará vários middlewares prontos, afinal é normal que sua aplicação gere logs de requisição, libere arquivos estáticos, reconheça alguns formatos de hypermidia (JSON, XML, HTML), converta dados de um formulário HTML para objeto JSON e faça várias outras tarefas que não listei aqui, assim como também execute tarefas específicas de sua aplicação.</p>
  <p>Neste último caso é mais provavel que você crie o seu próprio middleware e injete-o em seu app Express. Para isso você precisa apenas criar uma função que contenha os parâmetros "function(request, response, next)", pois ela será usada como callback dentro da função app.use(). É importante que seu middleware dê continuidade aos próximos fluxos de middlewares da aplicação, e para isso você apenas precisa executar a função next() que dita que seu middleware terminou com sucesso seu processamento e repassa a vez para um outro middleware ou rota continuar sua execução. Caso você queira cancelar o fluxo de execução dos próximos middlewares (geralmente porque violou alguma regra de negócio da aplicação ou um erro inesperado aconteceu) você pode finalizá-lo executando alguma função de resposta através do objeto response. Agora chega de palavras, vamos direto ao código! A seguir criaremos um middleware verifica se uma requisição contém a querystring version, caso ela não seja detectada o middleware cancelará o fluxo retornando um json de erro com status 500.</p>

{% highlight javascript %}
var express = require("express");
var morgan = require("morgan");
var compression = require("compression");
var app = express();

app.use(morgan());
app.use(compression());
app.use(function(req, res, next) {
  if (req.query.version) {
    next();
  } else {
    res.status(500).json({status: "Acesso negado!"});
  }
});

app.get("/", function(req, res) {
  res.json({status: "Hello!"});
});

app.listen(3000, function() {
  console.log("Servidor rodando!");
});
{% endhighlight %}

  <p>Para testar, veja os resultados ao acessar <a href="http://localhost:3000/" target="_blank">http://localhost:3000/</a> e <a href="http://localhost:3000/?version=1" target="_blank">http://localhost:3000/?version=1</a>.
  <br>
  Espero que tenham curtido o post e feedbacks serão sempre bem-vindos nos comentários abaixo! Até a próxima!
  </p>
</div>
