---
layout: post
title: Node.js para leigos - Explorando real-time
published: true
tags: Node.js
keywords: Curso de Node.js, Node.js, Node.js para leigos, Real-time, Socket.IO, WebSockets
description: O capítulo de hoje será muito interessante, falarei sobre um assunto emergente nos sistemas web, que esta sendo largamente utilizado com Node.js, o assunto é Real-time.
---
<figure class="post-image">
  <img src="{{ site.url }}/images/nodejs-para-leigos.jpg" width="250" height="137" alt="Curso de Node.js" title="Curso de Node.js">
  <figcaption>Curso de Node.js</figcaption>
</figure>
<div class="post-content">
<p>Fala galera! O capítulo de hoje será muito interessante, falarei sobre um assunto que esta muito emergente nos sistemas web, que esta sendo largamente utilizado no <a href="{{site.url}}/nodejs">Node.js</a>, <strong>o assunto é Real-time.</strong><br>
Quando se fala de aplicações real-time, estamos técnicamente falando de <strong>conexões bi-direcionais</strong>, que na prática, é uma <strong>conexão que se mantem aberta (keep-alive)</strong> para que os clientes interajam com o servidor em uma única conexão aberta. A grande vantagem disso é de não precisar mais das <strong>requisições assíncronas (AJAX)</strong> para simular uma <strong>“ação quase real-time”</strong>, digo quase pois <strong>AJAX não é uma conexão bi-direcional</strong> capaz de se manter aberta até o término de seu processamento.</p>
{% include content-ads.ext %}
<p>Node.js se tornou popular devido a sua facilidade em trabalhar com real-time, simplesmente por que o <strong>protocolo WebSockets (Protocolo do HTML5 para conexões bi-direcionais)</strong> utiliza-se Javascript também.<br>
O único problema em desenvolver aplicações real-time é que <strong>nem todos os browsers suportam o protocolo WebSockets</strong>, com isso ainda é <strong>inviável desenvolver uma aplicação 100% WebSockets</strong>. Diante desse problema <strong>surgiu um framework chamado Socket.IO</strong> cuja sua idéia resolve esse problema nos browsers antigos, <strong>emulando outras técnicas de comunicação real-time</strong> de forma totalmente abstrata para o desenvolvedor.<br>
Basicamente ele possui um script no client-side que detecta o browser e a compatibilidade adequada de comunicação.<br>
Ele tenta na seguinte ordem escolher qual técnica de comunicação será viável com o browser:<p></p>
<ol>
<li>WebSocket</li>
<li>Adobe&reg; Flash&reg; Socket</li>
<li>AJAX long polling</li>
<li>AJAX multipart streaming</li>
<li>Forever Iframe</li>
<li>JSONP Polling</li>
</ol>
<p>Com isso se o navegador for o mais recente Firefox ou Chrome e no server-side estiver habilitado o WebSockets, a comunicação será feita através desse protocolo. Porém se o usuário estiver no <strong>IE 6 sem o adobe flash player</strong> instalado, o nível de comunicação cai para <strong>Ajax long polling ou até JSONP polling</strong>, vai depender da decisão que é automática do Socket.IO client-side. Na maioria dos casos atuais, a conexão será através do <strong>Adobe Flash Player ou AJAX Long polling.</strong></p>
<p>O legal de tudo isso é que programar com Socket.IO é muito simples e toda decisão complexa é abstraída para o programador.</p>
<p>Abaixo, vejam uma versão simplificada de um chat real-time:</p>
<p>Para executar esse código, execute primeiro o comando:<br>
<strong>npm install express socket.io</strong></p>
{% highlight javascript %}
// server.js
// É necessário instanciar os módulos abaixo nessa ordem!
var app = require('express')()
  , server = require('http').createServer(app)
  , io = require('socket.io').listen(server);

server.listen(3000, function(){
  console.log("Chat real-time...");
});

app.get('/', function (req, res) {
  res.sendfile(__dirname + '/index.html');
});

// Eventos do Socket.IO
io.sockets.on('connection', function (socket) {

  socket.on('toServer', function (data) {
    var msg = data.nome+":"+data.msg;
    socket.emit('toClient', msg);
    socket.broadcast.emit('toClient', msg);
  });
});
{% endhighlight %}

{% highlight html %}
<!-- index.html -->
<html>
  <head>
    <title>Chat Real-time</title>
    <script src="/socket.io/socket.io.js"></script>
    <script>
      var socket = io.connect('http://localhost');
      socket.on('toClient', function (msg) {
        document.getElementById('historico').innerHTML += msg;
      });
      var enviar = function(){
        var nome = document.getElementById('nome').value;
        var msg = document.getElementById('mensagem').value;
        socket.emit('toServer', {nome: nome, msg: msg});
      };
    </script>
  </head>
  <body>
    <h1>Chat Real-time</h1>
    <label>Nome:
      <input type="text" id="nome" size="3">
    </label>
    <label>Mensagem:
      <input type="text" id="mensagem" size="10">
    </label>
    <button id="enviar" onclick="enviar();">Enviar</button>
    <hr>
    <div id="historico"></div>
  </body>
</html>
{% endhighlight %}

  <p>Acabamos de criar uma versão simples de um chat em real-time! No arquivo server.js somos obrigados a instanciar os módulos express, http e socket.io naquela ordem, pois é um motivo específico do próprio Socket.IO em que ele precisa escutar todas as ações do módulo http primeiro.</p>
  <p>Lembrando que estamos usando as últimas versões de todos esses módulos: <code>Express 3 e Socket.IO 0.9.x</code>. A boa prática é seguir exatamente a ordem apresentada neste exemplo anterior, que seria instanciar os módulos já deixando o express e socket.io executando seus métodos de listen(), depois criamos as rotas do express e por último os eventos real-time do socket.io.</p>

  {% include content-ads.ext %}

  <h4>Eventos server-side</h4>
  <ul>
    <li><code>io.sockets.on(‘connection’, function(socket))</code> - Ocorre quando o servidor recebe uma nova conexão de cliente.</li>
    <li><code>socket.on(‘message’, function(mensagem, callback))</code> - Ocorre quando um cliente usa a função send();, o callback desse evento serve para automaticamente responder o cliente no final da execução deste evento.</li>
    <li><code>socket.on(‘qualquer-nome-de-evento’, function(data))</code> - Eventos customizados pelo desenvolvedor, qualquer nome pode ser apelidado aqui e o seu comportamento é de apenas receber através do data dados enviados pelo cliente. No nosso exemplo prático, criamos o evento toServer.</li>
    <li><code>socket.on(‘disconnect’)</code> - Ocorre quando um cliente sai da área conectada ou emite o evento disconnect para o servidor.</li>
  </ul>
  <h4>Mensageria server-side</h4>
  <ul>
    <li><code>socket.emit(‘evento’, variaveis)</code> - Envia uma mensagem para o cliente que se comunicou com o servidor.</li>
    <li><code>socket.broadcast.emit(‘evento’, variaveis)</code> - Envia uma mensagem para todos os clientes conectados ao servidor, exceto o cliente que se comunicou com o servidor, ou seja, se numa sala de chat temos 4 clientes e o cliente X emitiu uma mensagem ao servidor, os outros 3 clientes receberão o retorno de uma mensagem menos o cliente X.</li>
  </ul>
  <h4>Eventos client-side</h4>
  <ul>
    <li><code>socket.on(‘connect’)</code> – Ocorre quando o cliente se conecta ao servidor.</li>
    <li><code>socket.on(‘connecting’)</code> – Ocorre quando o cliente esta se conectando ao servidor.</li>
    <li><code>socket.on(‘disconnect’)</code> – Ocorre quando o cliente deseja se desconectar do servidor.</li>
    <li><code>socket.on(‘connect_failed’)</code> – Ocorre quando o cliente não conseguiu se conectar no servidor.</li>
    <li><code>socket.on(‘error’)</code> – Ocorre quando o cliente já se conectou, porém ocorreu um erro grave no servidor durante as trocas de mensagens.</li>
    <li><code>socket.on(‘message’, function (message, callback))</code> – Ocorre quando o cliente envia uma mensagem de resposta rápida ao servidor, cuja resposta acontece através da função de callback.</li>
    <li><code>socket.on(‘qualquer-nome-de-evento’, function(data))</code> – Evento customizado pelo desenvolvedor. No nosso exemplo criamos o evento toClient.</li>
    <li><code>socket.on(‘reconnect_failed’)</code> – Ocorre quando o cliente não consegue se reconectar ao servidor.</li>
    <li><code>socket.on(‘reconnect’)</code> – Ocorre quando o cliente se reconecta ao servidor.</li>
    <li><code>socket.on(‘reconnecting’)</code> – Ocorre quando o cliente esta se reconectando ao servidor.</li>
  </ul>
  <h4>Mensageria client-side</h4>
  <ul>
    <li><code>socket.emit(‘evento’, variaveis)</code> - Envia uma mensagem para o cliente que se comunicou com o servidor.</li>
  </ul>
  <p>No client-side temos que adicionar o script:</p>
{% highlight html %}
<script src="/socket.io/socket.io.js"></script>
{% endhighlight %}
  <p>É automaticamente incluída pelo Socket.IO, não se preocupe em baixar esse arquivo apenas incluá-o em seu html.</p>

  <p>Bom galera, esse foi mais um capítulo do mini-curso, para melhores referências, segue abaixo os links utilizados:</p>
  <ul>
    <li><a href="{{site.url}}/real-time-com-socket-io-no-nodejs" title="Real-time com Socket.IO 1.0" rel="me">Real-time com Socket.IO 1.0</a></li>
    <li><a href="{{site.url}}/criando-um-chat-usando-session-do-express-4-no-socket-io-1-0" title="Criando um chat usando Session do Express 4 no Socket.IO 1.0" rel="me">Criando um chat usando Session do Express 4 no Socket.IO 1.0</a></li>
    <li><a href="https://github.com/LearnBoost/socket.io" title="Github do Socket.IO" target="_blank">Github do Socket.IO</a></li>
    <li><A href="https://github.com/LearnBoost/socket.io/wiki/Exposed-events" title="Socket.IO – Exposed Events" target="_blank">Socket.IO – Exposed Events</a></li>
  </ul>
  <p>Feliz 2013 a todos!</p>
</div>
